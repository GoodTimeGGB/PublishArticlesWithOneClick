/**
 * marked - a markdown parser
 * v4.3.0
 * Copyright (c) 2018-2022, Christopher Jeffrey (MIT License)
 * https://github.com/markedjs/marked
 * 
 * 简化版本 - 仅包含核心功能
 */

(function(global) {
  'use strict';

  function marked(src, opt) {
    return Parser.parse(Lexer.lex(src, opt), opt);
  }

  marked.options = marked.setOptions = function(opt) {
    marked.defaults = Object.assign({}, marked.defaults, opt);
    return marked;
  };

  marked.defaults = {
    gfm: true,
    breaks: false,
    pedantic: false,
    sanitize: false,
    smartLists: false,
    smartypants: false,
    xhtml: false
  };

  function Lexer(src, options) {
    this.tokens = [];
    this.tokens.links = Object.create(null);
    this.options = options || marked.defaults;
    this.rules = Lexer.rules;
    this.src = src;
  }

  Lexer.rules = {
    newline: /^\n+/,
    code: /^( {4}[^\n]+\n*)+/,
    fences: /^ {0,3}(`{3,}|~{3,})([^`~\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
    heading: /^ {0,3}(#{1,6}) +([^\n]*?)(?: +#+)?(?:\n+|$)/,
    nptable: /^ *([^|\n ].*\|.*)\n *([-:]+ *\|[-| :]*)(?:\n((?:.*[^>\n ].*(?:\n|$))*)\n*|$)/,
    blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
    list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
    html: '^ {0,3}(?:<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' +
      '|comment[^\\n]*(\\n+|$)' +
      '|<\\?[\\s\\S]*?\\?>\\n*' +
      '|<![A-Z][\\s\\S]*?>\\n*' +
      '|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\n*' +
      '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)' +
      '|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=\\n{2,}|$)' +
      '|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=\\n{2,}|$))',
    def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
    table: /^ *\|(.+)\n *\|?( *[-:]+[-| :]*)(?:\n((?: *[^>\n ].*(?:\n|$))*)\n*|$)/,
    lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
    paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading| {0,3}>|<\/?(?:tag)[^>]*>)[^\n]+)*)/,
    text: /^[^\n]+/
  };

  Lexer.lex = function(src, options) {
    var lexer = new Lexer(src, options);
    return lexer.lex();
  };

  Lexer.prototype.lex = function() {
    var src = this.src.replace(/\r\n|\r/g, '\n').replace(/\t/g, '    ');
    return this.token(src, true);
  };

  Lexer.prototype.token = function(src, top) {
    src = src.replace(/^ +$/gm, '');
    var next, loose, cap, bull, b, item, space, i, tag, l;

    while (src) {
      if (cap = this.rules.newline.exec(src)) {
        src = src.substring(cap[0].length);
        if (cap[0].length > 1) {
          this.tokens.push({ type: 'space' });
        }
      }

      if (cap = this.rules.code.exec(src)) {
        src = src.substring(cap[0].length);
        cap = cap[0].replace(/^ {4}/gm, '');
        this.tokens.push({
          type: 'code',
          text: !this.options.pedantic ? cap.replace(/\n+$/, '') : cap
        });
        continue;
      }

      if (cap = this.rules.fences.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          type: 'code',
          lang: cap[2] ? cap[2].trim() : cap[2],
          text: cap[3] || ''
        });
        continue;
      }

      if (cap = this.rules.heading.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          type: 'heading',
          depth: cap[1].length,
          text: cap[2]
        });
        continue;
      }

      if (cap = this.rules.blockquote.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({ type: 'blockquote_start' });
        cap = cap[0].replace(/^ *> ?/gm, '');
        this.token(cap, top);
        this.tokens.push({ type: 'blockquote_end' });
        continue;
      }

      if (cap = this.rules.list.exec(src)) {
        src = src.substring(cap[0].length);
        bull = cap[2];
        this.tokens.push({ type: 'list_start', ordered: bull.length > 1 });
        cap = cap[0].match(this.rules.item);
        next = false;
        l = cap.length;
        i = 0;

        for (; i < l; i++) {
          item = cap[i];
          space = item.length;
          item = item.replace(/^ *([*+-]|\d+\.) ?/, '');
          if (this.options.smartLists && i !== l - 1) {
            b = Lexer.rules.bullet.exec(cap[i + 1])[0];
            if (bull !== b && !(bull.length > 1 && b.length > 1)) {
              src = cap.slice(i + 1).join('\n') + src;
              i = l - 1;
            }
          }
          loose = next || /\n\n(?!\s*$)/.test(item);
          if (i !== l - 1) {
            next = item.charAt(item.length - 1) === '\n';
            if (!loose) loose = next;
          }
          this.tokens.push({ type: loose ? 'loose_item_start' : 'list_item_start' });
          this.token(item, false);
          this.tokens.push({ type: 'list_item_end' });
        }
        this.tokens.push({ type: 'list_end' });
        continue;
      }

      if (cap = this.rules.html.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          type: this.options.sanitize ? 'paragraph' : 'html',
          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
          text: cap[0]
        });
        continue;
      }

      if (top && (cap = this.rules.def.exec(src))) {
        src = src.substring(cap[0].length);
        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
        tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
        if (!this.tokens.links[tag]) {
          this.tokens.links[tag] = {
            href: cap[2],
            title: cap[3]
          };
        }
        continue;
      }

      if (cap = this.rules.table.exec(src)) {
        src = src.substring(cap[0].length);
        item = {
          type: 'table',
          header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
          align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
          cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
        };
        for (i = 0; i < item.align.length; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = 'right';
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = 'center';
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = 'left';
          } else {
            item.align[i] = null;
          }
        }
        for (i = 0; i < item.cells.length; i++) {
          item.cells[i] = item.cells[i].replace(/^ *\| *| *\| *$/g, '').split(/ *\| */);
        }
        this.tokens.push(item);
        continue;
      }

      if (cap = this.rules.lheading.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          type: 'heading',
          depth: cap[2] === '=' ? 1 : 2,
          text: cap[1]
        });
        continue;
      }

      if (cap = this.rules.paragraph.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          type: 'paragraph',
          text: cap[1].charAt(cap[1].length - 1) === '\n' ? cap[1].slice(0, -1) : cap[1]
        });
        continue;
      }

      if (cap = this.rules.text.exec(src)) {
        src = src.substring(cap[0].length);
        this.tokens.push({ type: 'text', text: cap[0] });
        continue;
      }

      if (src) {
        throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
      }
    }

    return this.tokens;
  };

  function Parser(options) {
    this.tokens = [];
    this.token = null;
    this.options = options || marked.defaults;
  }

  Parser.parse = function(src, options) {
    var parser = new Parser(options);
    return parser.parse(src);
  };

  Parser.prototype.parse = function(src) {
    this.inline = new InlineLexer(src.links, this.options);
    this.tokens = src.reverse();
    var out = '';
    while (this.next()) {
      out += this.tok();
    }
    return out;
  };

  Parser.prototype.next = function() {
    return this.token = this.tokens.pop();
  };

  Parser.prototype.tok = function() {
    switch (this.token.type) {
      case 'space':
        return '';
      case 'hr':
        return '<hr>\n';
      case 'heading':
        return '<h' + this.token.depth + '>' + this.inline.output(this.token.text) + '</h' + this.token.depth + '>\n';
      case 'code':
        if (this.options.highlight) {
          var code = this.options.highlight(this.token.text, this.token.lang);
          if (code != null && code !== this.token.text) {
            this.token.escaped = true;
            this.token.text = code;
          }
        }
        if (!this.token.escaped) {
          this.token.text = escape(this.token.text, true);
        }
        return '<pre><code' + (this.token.lang ? ' class="lang-' + this.token.lang + '"' : '') + '>' + this.token.text + '</code></pre>\n';
      case 'table':
        var header = '', body = '', i, row, cell, j;
        for (i = 0; i < this.token.header.length; i++) {
          header += '<th' + (this.token.align[i] ? ' style="text-align:' + this.token.align[i] + '"' : '') + '>' + this.inline.output(this.token.header[i]) + '</th>\n';
        }
        header = '<tr>\n' + header + '</tr>\n';
        for (i = 0; i < this.token.cells.length; i++) {
          row = this.token.cells[i];
          cell = '';
          for (j = 0; j < row.length; j++) {
            cell += '<td' + (this.token.align[j] ? ' style="text-align:' + this.token.align[j] + '"' : '') + '>' + this.inline.output(row[j]) + '</td>\n';
          }
          body += '<tr>\n' + cell + '</tr>\n';
        }
        return '<table>\n<thead>\n' + header + '</thead>\n<tbody>\n' + body + '</tbody>\n</table>\n';
      case 'blockquote_start':
        var body = '';
        while (this.next().type !== 'blockquote_end') {
          body += this.tok();
        }
        return '<blockquote>\n' + body + '</blockquote>\n';
      case 'list_start':
        var body = '', type = this.token.ordered ? 'ol' : 'ul';
        while (this.next().type !== 'list_end') {
          body += this.tok();
        }
        return '<' + type + '>\n' + body + '</' + type + '>\n';
      case 'list_item_start':
        var body = '';
        while (this.next().type !== 'list_item_end') {
          body += this.token.type === 'text' ? this.parseText() : this.tok();
        }
        return '<li>' + body + '</li>\n';
      case 'loose_item_start':
        var body = '';
        while (this.next().type !== 'list_item_end') {
          body += this.tok();
        }
        return '<li>' + body + '</li>\n';
      case 'html':
        return !this.token.pre && !this.options.pedantic ? this.inline.output(this.token.text) : this.token.text;
      case 'paragraph':
        return '<p>' + this.inline.output(this.token.text) + '</p>\n';
      case 'text':
        return '<p>' + this.parseText() + '</p>\n';
    }
  };

  Parser.prototype.parseText = function() {
    var body = this.token.text;
    while (this.next() && this.token.type === 'text') {
      body += '\n' + this.token.text;
    }
    return this.inline.output(body);
  };

  function InlineLexer(links, options) {
    this.options = options || marked.defaults;
    this.links = links;
    this.rules = InlineLexer.rules;
  }

  InlineLexer.rules = {
    escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
    autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
    url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
    tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^<'">])*?>/,
    link: /^!?\[(inside)\]\(href\)/,
    reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
    nolink: /^!?\[((?:\[[^\]]*\]|\\[\[\]]|[^\[\]])*)\]/,
    strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
    em: /^_([^\s_](?:[^_]|__)+?[^\s_])_\b|^\*((?:\*\*|[^*])+?)\*(?!\*)/,
    code: /^(`+)\s*([\s\S]*?[^`]?)\s*\1(?!`)/,
    br: /^ {2,}\n(?!\s*$)/,
    del: /^~~(?=\S)([\s\S]*?\S)~~/,
    text: /^[\s\S]+?(?=[\\<!\[_*`~]|https?:\/\/| {2,}\n|$)/,
    _inside: /(?:\[[^\]]*\]|\\[\[\]]|[^\[\]]|\](?=[^\[]*\]))*/,
    _href: /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/
  };

  InlineLexer.rules.link = new RegExp('^!?\\[(' + InlineLexer.rules._inside.source + ')\\]\\(' + InlineLexer.rules._href.source + '\\)');
  InlineLexer.rules.reflink = new RegExp('^!?\\[(' + InlineLexer.rules._inside.source + ')\\]\\s*\\[([^\\]]*)\\]');

  InlineLexer.prototype.output = function(src) {
    var out = '', link, text, href, cap;

    while (src) {
      if (cap = this.rules.escape.exec(src)) {
        src = src.substring(cap[0].length);
        out += cap[1];
        continue;
      }

      if (cap = this.rules.autolink.exec(src)) {
        src = src.substring(cap[0].length);
        if (cap[2] === '@') {
          text = cap[1].charAt(6) === ':' ? cap[1].substring(7) : cap[1];
          href = 'mailto:' + text;
        } else {
          href = cap[1];
          text = cap[1];
        }
        out += '<a href="' + href + '">' + text + '</a>';
        continue;
      }

      if (cap = this.rules.url.exec(src)) {
        src = src.substring(cap[0].length);
        href = cap[1];
        text = cap[1];
        out += '<a href="' + href + '">' + text + '</a>';
        continue;
      }

      if (cap = this.rules.tag.exec(src)) {
        src = src.substring(cap[0].length);
        out += this.options.sanitize ? '' : cap[0];
        continue;
      }

      if (cap = this.rules.link.exec(src)) {
        src = src.substring(cap[0].length);
        out += this.outputLink(cap, { href: cap[2], title: cap[3] });
        continue;
      }

      if ((cap = this.rules.reflink.exec(src)) || (cap = this.rules.nolink.exec(src))) {
        src = src.substring(cap[0].length);
        link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
        link = this.links[link.toLowerCase()];
        if (!link || !link.href) {
          out += cap[0].charAt(0);
          src = cap[0].substring(1) + src;
          continue;
        }
        out += this.outputLink(cap, link);
        continue;
      }

      if (cap = this.rules.strong.exec(src)) {
        src = src.substring(cap[0].length);
        out += '<strong>' + this.output(cap[2] || cap[1]) + '</strong>';
        continue;
      }

      if (cap = this.rules.em.exec(src)) {
        src = src.substring(cap[0].length);
        out += '<em>' + this.output(cap[2] || cap[1]) + '</em>';
        continue;
      }

      if (cap = this.rules.code.exec(src)) {
        src = src.substring(cap[0].length);
        out += '<code>' + escape(cap[2], true) + '</code>';
        continue;
      }

      if (cap = this.rules.br.exec(src)) {
        src = src.substring(cap[0].length);
        out += '<br>';
        continue;
      }

      if (cap = this.rules.del.exec(src)) {
        src = src.substring(cap[0].length);
        out += '<del>' + this.output(cap[1]) + '</del>';
        continue;
      }

      if (cap = this.rules.text.exec(src)) {
        src = src.substring(cap[0].length);
        out += escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
        continue;
      }

      if (src) {
        throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
      }
    }

    return out;
  };

  InlineLexer.prototype.outputLink = function(cap, link) {
    var href = escape(link.href), title = link.title ? escape(link.title) : null;
    return cap[0].charAt(0) !== '!' ? '<a href="' + href + '"' + (title ? ' title="' + title + '"' : '') + '>' + this.output(cap[1]) + '</a>' : '<img src="' + href + '" alt="' + escape(cap[1]) + '"' + (title ? ' title="' + title + '"' : '') + '>';
  };

  function escape(html, encode) {
    return html.replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
  }

  function smartypants(text) {
    return text.replace(/---/g, '\u2014').replace(/--/g, '\u2013').replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018').replace(/'/g, '\u2019').replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c').replace(/"/g, '\u201d').replace(/\.{3}/g, '\u2026');
  }

  if (typeof module !== 'undefined' && typeof exports === 'object') {
    module.exports = marked;
  } else if (typeof define === 'function' && define.amd) {
    define(function() { return marked; });
  } else {
    global.marked = marked;
  }

})(this);
